import <%=symbol%>_token<%=tokenVersion%>.aleo;
import <%=symbol%>_holding<%=holdingVersion%>.aleo;
import token_service<%=tokenServiceVersion%>.aleo;
import council<%=councilVersion%>.aleo;

program <%=symbol%>_connector<%=connectorVersion%>.aleo {

    // <%=symbol%>_token<%=tokenVersion%>.aleo as address
    const <%=symbol.toUpperCase()%>_TOKEN: address = <%=aleoTokenAddr%>;

    // <%=symbol%>_holding<%=holdingVersion%>.aleo as address
    const <%=symbol.toUpperCase()%>_HOLDING: address = <%=aleoTokenHoldingAddr%>;

    //////////////////////////////
    /////// Initialization ///////
    //////////////////////////////

    // Initialize can only be called once
    transition initialize_<%=symbol%>() {
        <%=symbol%>_token<%=tokenVersion%>.aleo/initialize_token(name(), symbol(), decimals());
        <%=symbol%>_holding<%=holdingVersion%>.aleo/initialize_holding();
    }

    /// Receive Wrapped USDC
    ///
    /// # Arguments:
    /// * sender: [u8; 32] - Address of the sender on source chain (Ethereum)
    /// * receiver: address - Receiver on the packet in Aleo
    /// * actual_receiver: address - Address where the token is minted on Aleo
    /// * amount: u128 - Amount to be minted on Aleo
    /// * sequence: u32 - Sequence no for this chain on the source chain
    /// * height: u32 - Height of the source chain where the packet originated
    /// * signers: [address; 5] - Addresses of the attestors who have signed the packet
    /// * signs: [signature; 5] - Signatures of the attestors after signing the packet
    transition <%=symbol%>_receive(
        public sender: [u8; 32], 
        public receiver: address, 
        public actual_receiver: address, 
        public amount: u128, 
        public sequence: u64, 
        public height: u32, 
        public signers: [address; 5], 
        public signs: [signature; 5]
    ) {

        token_service<%=tokenServiceVersion%>.aleo/token_receive(
            origin_chain_id(), 
            origin_token_service_address(), 
            origin_token_address(), 
            <%=symbol.toUpperCase()%>_TOKEN, 
            sender, 
            receiver, 
            actual_receiver, 
            amount, 
            sequence, 
            height, 
            signers, 
            signs
        );

        <%=symbol%>_token<%=tokenVersion%>.aleo/mint_public(actual_receiver, amount);

        // If the packet did not pass the screening, the `actual_receiver` must be the holding program
        // In case the packet passed the screening, the receiver and the actual receiver are the same address.
        // And additional checks are not required
        let check_required: bool = !(receiver == actual_receiver);

        if check_required {
            assert_eq(actual_receiver, <%=symbol.toUpperCase()%>_HOLDING);
            <%=symbol%>_holding<%=holdingVersion%>.aleo/hold_fund(receiver, amount);
        }

    }

    transition <%=symbol%>_send(public receiver: [u8; 32], public amount: u128) {

        <%=symbol%>_token<%=tokenVersion%>.aleo/burn_public(self.caller, amount);

        token_service<%=tokenServiceVersion%>.aleo/token_send(
            <%=symbol.toUpperCase()%>_TOKEN, 
            self.caller, 
            receiver, 
            amount, 
            origin_chain_id(), 
            origin_token_address(), 
            origin_token_service_address()
        );

    }

    ///////////////////////////////
    ///// Update Connector ////////
    ///////////////////////////////

    /// Update the existing connector program
    /// Can only be called if proposal with enough votes exist on council program
    transition update(public proposal_id: u32, public new_connector: address) {
        council<%=councilVersion%>.aleo/connector_update(proposal_id, <%=symbol.toUpperCase()%>_TOKEN, new_connector);
        <%=symbol%>_token<%=tokenVersion%>.aleo/transfer_ownership_token(new_connector);
        <%=symbol%>_holding<%=holdingVersion%>.aleo/transfer_ownership_holding(new_connector);
        token_service<%=tokenServiceVersion%>.aleo/update_connector_ts(<%=symbol.toUpperCase()%>_TOKEN, new_connector);
    }


    /// Release fund from holding program
    /// Can only be called if proposal with enough votes exist on council program
    transition <%=symbol%>_release(public proposal_id: u32, public receiver: address, public amount: u128) {
        council<%=councilVersion%>.aleo/holding_release(proposal_id, <%=symbol.toUpperCase()%>_TOKEN, receiver, amount);
        <%=symbol%>_holding<%=holdingVersion%>.aleo/release_fund(receiver, amount);
    }


    // Chain Id of the network
    // Chain Id is generated as {network_type}:{chain_id} where `network_id` is represented as ASCII and `chain_id` is a number, `:` is separator
    // For Ethereum Sepolia testnet, chain_id: `eth:11155111` -> 28556963657430695
    inline origin_chain_id() -> u128 {
        return <%=originChainId%>;
    }

    // Contract Address of the original token on the origin chain
    // Represented as bytes32 zero-left-padded (Similar to Wormhole address)
    // Example: Contract Address of USDC on Ethereum
    // For EVM Chains, 20 bytes is formatted as following:
    inline origin_token_address() -> [u8; 32] {
        return <%=originTokenAddress%>;
    }

    // Token Service Contract Address of the original token on the origin chain
    // Represented as bytes32 zero-left-padded (Similar to Wormhole address)
    // Example: Contract Address of USDC on Ethereum
    // For EVM Chains, 20 bytes is formatted as following:
    inline origin_token_service_address() -> [u8; 32] {
        return <%=originTokenServiceAddress%>;
    }

    // Name of the token
    // Represented as hexadecimal bytes for ASCII text zero-right-padded (Similar to privacy_pride)
    // Example: `USD Coin` is represented as following (hex):
    // [55 53 44 20 43 6f 69 6e 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00]
    // Storing in const? Error [ETYC0372080]: The value of a const declaration must be a literal
    inline name() -> [u8; 32] {
        return <%=nameInArray%>;
    }

    // Symbol of the token
    // Represented as hexadecimal bytes for ASCII text zero-right-padded (Similar to privacy_pride)
    // Example: `USDC` is represented as following (hex):
    // [55 53 44 43 00 00 00 00 00 00 00 00 00 00 00 00] 
    inline symbol() -> [u8; 16] {
        return <%=symbolInArray%>;
    }

    // Decimals of the token
    inline decimals() -> u8 {
        return <%=decimals%>;
    }



}